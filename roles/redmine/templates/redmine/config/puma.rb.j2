#!/usr/bin/env puma
{{ managed_by_ansible | comment }}

environment '{{ redmine_rails_env }}'

pidfile '{{ redmine_run_base_path + "/" + redmine_instance_name }}/redmine.pid'
state_path '{{ redmine_run_base_path + "/" + redmine_instance_name }}/redmine.state'
bind 'unix://{{ redmine_run_base_path + "/" + redmine_instance_name }}/redmine.sock'

workers {{ real_puma_workers | int }}
threads {{ redmine_instance.puma_min_threads | default(redmine_puma_min_threads) }}, {{ redmine_instance.puma_max_threads | default(redmine_puma_max_threads) }}

{% if real_puma_workers | int > 3 %}
wait_for_less_busy_worker
{% endif %}
{% if redmine_instance.with_dmsf is defined and redmine_instance.with_dmsf %}
supported_http_methods(Puma::Const::SUPPORTED_HTTP_METHODS + ['PROPFIND', 'PROPPATCH', 'MKCOL', 'COPY', 'MOVE', 'LOCK', 'UNLOCK'])
{% endif %}

# @see https://www.rubydoc.info/gems/puma/Puma%2FDSL:worker_timeout
worker_timeout {{ redmine_puma_worker_timeout }}
{% if real_puma_workers | int > 1 %}

before_worker_boot do
  ActiveRecord::Base.establish_connection
end

preload_app!
{% endif %}
{% if (redmine_instance.puma_warmup | default(redmine_puma_warmup)) | bool %}

after_booted do
  Thread.new do
    sleep 3
    require 'socket'
    UNIXSocket.open('{{ redmine_run_base_path + "/" + redmine_instance_name }}/redmine.sock') do |sock|
      sock.write "GET / HTTP/1.0\r\nHost: localhost\r\n\r\n"
      sock.read
    end
  rescue StandardError => e
    # Warmup failed, not critical
  end
end
{% endif %}

# === Puma control rack application ===
activate_control_app 'unix://{{ redmine_run_base_path + "/" + redmine_instance_name }}/redmine-pumactl.sock', { no_token: true }
